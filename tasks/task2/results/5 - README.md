# Миграция бронирований в отдельный сервис

## Кратко

Запускаем новый **booking-service** (gRPC, своя БД), перенаправляем из монолита только **создание бронирований** на gRPC, оставляя остальные вызовы в монолите. Новый сервис публикует событие `booking-created` в Kafka. Отдельный **booking-history-service** читает события и ведёт агрегаты без нагрузки на боевую БД. Это классическая миграция по **Strangler Fig**: постепенно «обвиваем» монолит новыми компонентами и вырезаем старую логику.

## Текущее (As-Is)

* Монолит `hotelio-monolith` с собственной БД `hotelio` (таблицы: `app_user`, `hotels`, `bookings`, ...).
* Все операции бронирования выполняются внутри монолита.
* Аналитики читают данные напрямую из боевой БД → риск нагрузки.

## Целевое (To-Be)

* gRPC-сервис `booking-service`:
  * своя БД `booking` (таблица `public.bookings`);
  * контракт `booking.proto` (`CreateBooking`, `ListBookings`);
  * после успешного `CreateBooking` публикует в Kafka событие `booking-created`.

* `booking-history-service`:
  * своя БД `booking_history` (например, таблица `booking_stats`);
  * асинхронно считает историю/агрегаты из Kafka.

* Монолит:
  * проксирует только **создание** через gRPC (включается env-переменными);
  * чтения временно остаются как были (постепенно переносим).

## Инфраструктура

* **Kafka**: `kafka:9092`, топик `booking-created`.

* **БД**:
  * monolith: контейнер `hotelio-db`, база `hotelio`, пользователь `hotelio`.
  * booking: контейнер `booking-db`, база `booking`, пользователь `booking`.
  * history: контейнер `booking-history-db`, база `booking_history`, пользователь `booking_history`.

* **Переменные для прокси в монолите**:
  ```
  BOOKING_SERVICE_EXTERNAL_HOST=booking-service
  BOOKING_SERVICE_EXTERNAL_PORT=9090
  ```

## План миграции (Strangler Fig)

1. **Подготовка**
   * Поднять Kafka и Zookeeper.
   * Запустить `booking-service` + отдельную БД.
   * Запустить `booking-history-service` + отдельную БД.
   * В монолите включить gRPC-прокси (env выше).
   * Прогреть инициализацию (сидирование пользователей/отелей).

2. **Один раз (backfill, если есть старые данные)**
   * Если в старой БД `hotelio.booking` есть записи, выполнить офлайн-миграцию:
     * выгрузка батчами → запись в `booking.bookings`,
     * публикация исторических `booking-created` (либо запуск отдельного backfill-джоба в history-сервисе).
   * Идемпотентность по `id`, чтобы исключить дубликаты в случае повторов.

3. **Включение записи через gRPC**
   * Монолит перенаправляет только **Create** в `booking-service`.
   * `booking-service` сохраняет запись в свою БД и публикует `booking-created`.
   * `booking-history-service` потребляет и обновляет агрегаты в `booking_history`.

4. **Верификация**
   * Создать одно/несколько бронирований.
   * Проверить:
     * новая БД: запись появилась в `booking.public.bookings`;
     * старая БД: **нет** новых записей (ожидаемо);
     * история: агрегаты в `booking_history` обновились.
   * Автотесты/скрипт `regress.sh` (см. `test-log.txt`).

5. **Постепенное вырезание**
   * Переносить чтения из монолита на `booking-service` (через gRPC/REST-обёртку).
   * Удалить из монолита таблицу/код бронирований после полного перевода.
   * Оставить history-сервис как источник аналитики/витрин.

## Обеспечение целостности

* **Outbox / Transactional outbox** в `booking-service` (рекомендуется) для надёжной публикации в Kafka.
* **Идемпотентные потребители** в `booking-history-service` (обработка повторов).
* **Мониторинг/алерты**:
  * лаги потребителя Kafka,
  * dead-letter topic для проблемных сообщений,
  * метрики insert/latency в новых БД.

## Роллбэк

* На время пилота прокси легко выключается: убрать env у монолита → запись снова пойдёт в монолит.
* Данные, созданные в новом сервисе, остаются валидны; при необходимости — обратный ETL (редко нужен).

## Почему это безопасно

* Пишем в новую БД, не нагружая монолит.
* Аналитика уходит в асинхронный контур через Kafka.
* Переключение по одной операции (сначала Create) снижает риск.
* Лёгкий откат (env-флаг), измеримая верификация.

## Следующие шаги (To-Be расширение)

* Обернуть `booking-service` REST-шлюзом для внешних клиентов.
* Перевести все чтения из монолита на новый сервис.
* Включить outbox-паттерн и DLQ в проде.
* Архивировать/удалить таблицы бронирований из `hotelio`.

---

**Итог:** Создание бронирований ушло из монолита в `booking-service`, данные пишутся в новую БД и публикуются в Kafka, `booking-history-service` формирует статистику. Миграция реализована по Strangler Fig и готова к пошаговому расширению до полного выноса функционала.
